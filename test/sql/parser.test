# name: test/sql/parser.test
# description: test parser extension functions
# group: [parser]

require capi_quack

# =============================================================================
# SCALAR FUNCTIONS
# =============================================================================

# -----------------------------------------------------------------------------
# is_valid_sql(query) -> BOOLEAN
# -----------------------------------------------------------------------------

query I
SELECT is_valid_sql('SELECT 1')
----
true

query I
SELECT is_valid_sql('SELECT * FROM users')
----
true

query I
SELECT is_valid_sql('SELEC 1')
----
false

query I
SELECT is_valid_sql('SELECT * FROM')
----
false

# -----------------------------------------------------------------------------
# num_statements(query) -> BIGINT
# -----------------------------------------------------------------------------

query I
SELECT num_statements('SELECT 1')
----
1

query I
SELECT num_statements('SELECT 1; SELECT 2; SELECT 3')
----
3

query I
SELECT num_statements('SELECT 1; INSERT INTO t VALUES (1); DELETE FROM t')
----
3

query I
SELECT num_statements('INVALID SQL')
----
0

# -----------------------------------------------------------------------------
# sql_error_message(query) -> VARCHAR
# -----------------------------------------------------------------------------

query I
SELECT sql_error_message('SELECT 1') IS NULL
----
true

query I
SELECT sql_error_message('SELEC 1') LIKE '%syntax error%'
----
true

# -----------------------------------------------------------------------------
# is_keyword(identifier) -> BOOLEAN
# -----------------------------------------------------------------------------

query I
SELECT is_keyword('SELECT')
----
true

query I
SELECT is_keyword('select')
----
true

query I
SELECT is_keyword('FROM')
----
true

query I
SELECT is_keyword('mytable')
----
false

query I
SELECT is_keyword('foo')
----
false

# -----------------------------------------------------------------------------
# sql_strip_comments(query) -> VARCHAR
# -----------------------------------------------------------------------------

query I
SELECT length(sql_strip_comments('SELECT 1 -- comment'))
----
9

query T
SELECT sql_strip_comments('SELECT /* block */ 1')
----
SELECT  1

query T
SELECT sql_strip_comments('SELECT ''not--comment''')
----
SELECT 'not--comment'

# -----------------------------------------------------------------------------
# parse_table_names(query) -> VARCHAR[]
# -----------------------------------------------------------------------------

query T
SELECT parse_table_names('SELECT 1')
----
[]

# -----------------------------------------------------------------------------
# parse_function_names(query) -> VARCHAR[]
# -----------------------------------------------------------------------------

query I
SELECT list_sort(parse_function_names('SELECT UPPER(''x''), LENGTH(''y'')'))
----
[length, upper]

query I
SELECT list_sort(parse_function_names('SELECT COUNT(*), SUM(1)'))
----
[count_star, sum]

query T
SELECT parse_function_names('SELECT 1')
----
[]

# -----------------------------------------------------------------------------
# sql_parse_json(query) -> VARCHAR (JSON)
# -----------------------------------------------------------------------------

# Valid query returns error=false
query T
SELECT json_extract_string(sql_parse_json('SELECT 1'), '$.error')
----
false

# Can extract plan type
query T
SELECT json_extract_string(sql_parse_json('SELECT 1'), '$.plans[0].type')
----
LOGICAL_PROJECTION

# Can extract expression info
query T
SELECT json_extract_string(sql_parse_json('SELECT 1 + 2 AS result'), '$.plans[0].expressions[0].alias')
----
result

# Can extract function name from expression
query T
SELECT json_extract_string(sql_parse_json('SELECT 1 + 2'), '$.plans[0].expressions[0].name')
----
+

# Invalid query returns error=true
query T
SELECT json_extract_string(sql_parse_json('INVALID SQL'), '$.error')
----
true

# Invalid query includes error message
query I
SELECT json_extract_string(sql_parse_json('INVALID SQL'), '$.error_message') LIKE '%syntax error%'
----
true

# =============================================================================
# TABLE FUNCTIONS
# =============================================================================

# -----------------------------------------------------------------------------
# sql_keywords() -> table(keyword)
# -----------------------------------------------------------------------------

query I
SELECT COUNT(*) > 50 FROM sql_keywords()
----
true

query T
SELECT keyword FROM sql_keywords() WHERE keyword = 'SELECT'
----
SELECT

query T
SELECT keyword FROM sql_keywords() WHERE keyword = 'FROM'
----
FROM

query T
SELECT keyword FROM sql_keywords() WHERE keyword = 'WHERE'
----
WHERE

# -----------------------------------------------------------------------------
# parse_statements(query) -> table(stmt_index, stmt_type, error, param_count)
# -----------------------------------------------------------------------------

query ITTI
SELECT * FROM parse_statements('SELECT 1')
----
0	SELECT	NULL	0

query IT
SELECT stmt_index, stmt_type FROM parse_statements('SELECT 1; SELECT 2') ORDER BY stmt_index
----
0	SELECT
1	SELECT

query T
SELECT stmt_type FROM parse_statements('CREATE TABLE t(x INT)')
----
CREATE

query T
SELECT stmt_type FROM parse_statements('SET memory_limit=''1GB''')
----
SET

query I
SELECT param_count FROM parse_statements('SELECT $1, $2, $3')
----
3

query T
SELECT stmt_type FROM parse_statements('INVALID SQL')
----
INVALID

query I
SELECT error IS NOT NULL FROM parse_statements('INVALID SQL')
----
true

# -----------------------------------------------------------------------------
# parse_parameters(query, stmt_index) -> table(param_index, param_name, param_type)
# -----------------------------------------------------------------------------

query IT
SELECT param_index, param_name FROM parse_parameters('SELECT $1, $2', 0) ORDER BY param_index
----
0	1
1	2

query I
SELECT COUNT(*) FROM parse_parameters('SELECT 1', 0)
----
0

# -----------------------------------------------------------------------------
# parse_columns(query, stmt_index) -> table(col_index, col_name, col_type)
# -----------------------------------------------------------------------------

query ITT
SELECT * FROM parse_columns('SELECT 1 AS num, ''hello'' AS str', 0)
----
0	num	INTEGER
1	str	VARCHAR

query IT
SELECT col_index, col_type FROM parse_columns('SELECT 1, 2, 3, 4, 5', 0) ORDER BY col_index
----
0	INTEGER
1	INTEGER
2	INTEGER
3	INTEGER
4	INTEGER

# -----------------------------------------------------------------------------
# parse_column_types(query, stmt_index) -> table(col_index, col_name, base_type, full_type)
# -----------------------------------------------------------------------------

query ITTT
SELECT * FROM parse_column_types('SELECT 1 AS x', 0)
----
0	x	INTEGER	INTEGER

query T
SELECT full_type FROM parse_column_types('SELECT [1,2,3] AS arr', 0)
----
INTEGER[]

query T
SELECT full_type FROM parse_column_types('SELECT {a: 1, b: ''x''} AS s', 0)
----
STRUCT(a INTEGER, b VARCHAR)

# -----------------------------------------------------------------------------
# parse_type_info(query, stmt_index, col_index) -> table(base_type, full_type, ...)
# -----------------------------------------------------------------------------

query TT
SELECT base_type, full_type FROM parse_type_info('SELECT 1', 0, 0)
----
INTEGER	INTEGER

query TT
SELECT base_type, full_type FROM parse_type_info('SELECT [1,2,3]', 0, 0)
----
LIST	INTEGER[]

# -----------------------------------------------------------------------------
# tokenize_sql(query) -> table(byte_position, category)
# -----------------------------------------------------------------------------

query IT
SELECT * FROM tokenize_sql('SELECT * FROM tbl')
----
0	KEYWORD
7	OPERATOR
9	KEYWORD
14	IDENTIFIER

query I
SELECT COUNT(*) FROM tokenize_sql('SELECT a, b, c FROM t WHERE x > 1')
----
12

query T
SELECT category FROM tokenize_sql('SELECT 123') WHERE byte_position = 7
----
NUMERIC_CONSTANT

query T
SELECT category FROM tokenize_sql('SELECT ''hello''') WHERE byte_position = 7
----
STRING_CONSTANT

# -----------------------------------------------------------------------------
# parse_tables(query) -> table(schema, table, context)
# -----------------------------------------------------------------------------

# Note: parse_tables requires tables to exist in the in-memory db it creates
# So we test with queries that don't reference tables
query I
SELECT COUNT(*) FROM parse_tables('SELECT 1')
----
0

# -----------------------------------------------------------------------------
# parse_functions(query) -> table(function_name, function_type)
# -----------------------------------------------------------------------------

query TT
SELECT * FROM parse_functions('SELECT UPPER(''x'')') ORDER BY function_name
----
upper	scalar

query TT
SELECT * FROM parse_functions('SELECT COUNT(*)') ORDER BY function_name
----
count_star	aggregate

query TT
SELECT * FROM parse_functions('SELECT COUNT(*), SUM(1), LOWER(''X'')') ORDER BY function_name
----
count_star	aggregate
lower	scalar
sum	aggregate

query I
SELECT COUNT(*) FROM parse_functions('SELECT 1')
----
0

# -----------------------------------------------------------------------------
# parse_where(query) -> table(column_name, operator, value)
# -----------------------------------------------------------------------------

query TT
SELECT operator, value FROM parse_where('SELECT 1 WHERE 1 > 0')
----
>	0

query TT
SELECT operator, value FROM parse_where('SELECT 1 WHERE 5 = 5 AND 10 < 20') ORDER BY value
----
<	20
=	5

query I
SELECT COUNT(*) FROM parse_where('SELECT 1')
----
0
